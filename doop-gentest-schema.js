#!/usr/bin/env node

var _ = require('lodash');
var async = require('async-chainable');
var asyncExec = require('async-chainable-exec');
var asyncFlush = require('async-chainable-flush');
var colors = require('chalk');
var doop = require('.');
var fs = require('fs');
var fspath = require('path');
var glob = require('glob');
var program = require('commander');
var temp = require('temp');

program
	.version(require('./package.json').version)
	.usage('[units...]')
	.description('Generate Mocha/Chai tests from unit schema files')
	.option('-v, --verbose', 'Be verbose. Specify multiple times for increasing verbosity', function(i, v) { return v + 1 }, 0)
	.option('--no-clobber', 'Dont attempt to update existing files')
	.parse(process.argv);

async()
	.use(asyncFlush)
	.then(doop.chProjectRoot)
	.then(doop.getUserSettings)
	// Load project database {{{
	.then('models', function(next) {
		global.app = require(doop.settings.paths.project + '/units/core/app');
		global.app.config = require(doop.settings.paths.project + '/config/index.conf');
		require(doop.settings.paths.project + '/units/db/loader')(next);
	})
	// }}}
	// Filter down models by program.args (if any) {{{
	.then('models', function(next) {
		if (!program.args.length) return next(null, this.models);
		next(null, _.omitBy(this.models, (v, k) => !_.includes(program.args, k)));
	})
	// }}}
	// Pre-generate sanity checks {{{
	.then(function(next) {
		if (!_.keys(this.models).length) return next('No models to create schemas for');
		next();
	})
	// }}}
	// Generate testkit {{{
	// Prescan unit models to check they dont already exist (or decorate with the path if thats ok)
	.forEach('models', function(next, model, unit) {
		model._testKit = {
			pathRead: doop.settings.paths.project + '/units/' + unit + '/' + unit + '.test.js',
			pathExisting: false,
		};
		model._testKit.pathWrite = model._testKit.pathRead;

		fs.stat(model._testKit.pathRead, function(err, stat) {
			if (stat) {
				if (!program.clobber) return next('Refusing to overwrite "' + model._testKit.pathRead + '"');
				if (program.verbose) console.log('- testkit for', colors.cyan(unit), 'already exists');
				model._testKit.pathWrite = temp.path({suffix: '--' + fspath.basename(model._testKit.pathRead)});
				model._testKit.pathExisting = true;
				next();
			} else {
				next();
			}
		});
	})
	.forEach('models', function(next, model, unit) {
		model._testKit.generated = {};

		async()
			.parallel({
				get: function(next) {
					var testKit = model._testKit.generated.get = [
						"\tit('GET /api/" + unit + "', function(done) {",
						"\t\t// Auto-generated by doop-cli",
						"\t\tapp.test.agent.get(app.config.url + '/api/" + unit + "')",
						"\t\t\t.end(function(err, rs) {",
						"\t\t\t\tif (res.body.error) return done(res.body.error);",
						"\t\t\t\texpect(err).to.not.be.ok;",
						"",
						"\t\t\t\tres.body.forEach(function(i) {",
					];

					_.forEach(model.$mongooseModel.schema.paths, function(attr, id) {
						if (id.split('.').length > 1) return; // Complex path - ignore for now
						if (id == '__v') return; // Weird item - ignore for now

						if (id.startsWith('_') && id != '_id') { // Hidden value?
							testKit.push("\t\t\t\t\texpect(i).to.not.have.property('" + id + "');");
						} else {
							testKit.push("\t\t\t\t\texpect(i).to.have.property('" + id + "');");
							switch (attr.instance.toLowerCase()) {
								case 'string':
									testKit.push("\t\t\t\t\texpect(i." + id + ").to.be.a.string;");
									break;
								case 'number':
									testKit.push("\t\t\t\t\texpect(i." + id + ").to.be.a.number;");
									break;
								case 'date':
									testKit.push("\t\t\t\t\texpect(i." + id + ").to.be.a.date;");
									break;
							}
						}
					});

					testKit.push('');
					testKit.push('\t\t\t\t\tdone();');
					testKit.push('\t\t\t\t});');
					testKit.push('\t\t\t});');
					testKit.push('\t\t});');
					testKit.push('\t});');
					next();
				},
			})
			.end(next);
	})
	// }}}
	// Write main file / temporary file {{{
	.forEach('models', function(next, model, unit) {
		if (program.verbose >= 2) console.log('Write', model._testKit.pathWrite);
		var outStream = fs.createWriteStream(model._testKit.pathWrite);
		outStream.on('finish', next);

		outStream.write("describe('ReST accessor /api/" + unit + "', function() {\n\n");

		_.forEach(model._testKit.generated, function(text, method) {
			outStream.write(text.join('\n'));
		});

		outStream.write("\n\n});");
		outStream.end();
	})
	// }}}
	// Open merge session when needed {{{
	.forEach('models', function(next, model, unit) {
		if (model._testKit.pathRead == model._testKit.pathWrite) return next(); // Merge not needed
		if (program.verbose) console.log('Merge', colors.cyan(model._testKit.pathRead), colors.cyan(model._testKit.pathWrite));

		async()
			.use(asyncExec)
			.execDefaults({stdio: 'inherit'})
			.exec([
				'meld',
				model._testKit.pathRead,
				model._testKit.pathWrite,
			])
			.end(next);
	})
	// }}}
	// End {{{
	.flush()
	.end(function(err) {
		if (err) {
			console.log(colors.red('Doop Error'), err.toString());
			process.exit(1);
		} else {
			process.exit(0);
		}
	});
	// }}}
